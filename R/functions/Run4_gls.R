Run4_gls <- function(patterns, res.listName, res.list=NULL, res.list.ids=NULL, 
                     res.list.lengths=NULL, mod.comb, out.filename, 
                     modseq.dir=NULL, out.dir=NULL, num.cores=numeric(0)) {
  
  ## Function arguments
  # patterns      Data frame containing the sequences of the various variants
  #               per module. Columns correspond to different modules and rows 
  #               correspond to variants identifiers. Alternatively, it can 
  #               represent the path to the csv file.
  # res.listName  Autogenerated name for output files or name of the R object  
  #               storing the list of results from the read mapping (without 
  #               the file extension).
  # modseq.dir    (optional) modseq's head directory, by default current working
  #               directory.
  # out.dir       (optional) Path to output files.
  # num.cores     (optional) number of cores available for performing parallel 
  #               tasks.
  
  ## Whenever modseq path or output directory are not specified, assumed to be 
  #  the current working directory
  if (is.null(modseq.dir)) {
    modseq.dir <- getwd()
    warning("Object \'modseq.dir\' not found, set to: \"", modseq.dir, "\".")
  } 
  if (is.null(out.dir)) {
    out.dir <- getwd()
  }
  
  if (length(num.cores) == 0) {
    num.cores <- detectCores()
  }
  
  if (!existsFunction("GetVariantsNames")) {
    source(file.path(modseq.dir, "R/functions/GetVariantsNames.R"))
  }
  source(file.path(modseq.dir, "R/functions/PlotVariantFrequencies.R"))
  source(file.path(modseq.dir, "R/functions/PlotModuleCombinationsDistribution.R"))
  
  ## Loading module table
  if (!is.data.frame(patterns)) {
    
    if(!existsFunction("LoadModuleTable")) {
      source(file.path(modseq.dir, "R/functions/LoadModuleTable.R"))
    }
    if (is.character(patterns)) {
      patterns <- LoadModuleTable(in.modulesDir = patterns) 
    } else {
      stop("Invalid data type for \'patterns\', \"", class(patterns), "\".\n")
    }
  }
  mod.tot <- ncol(patterns)
  mod.number <- sapply(patterns, function(x) length(na.omit(x)))
  
  patterns.list <- as.character(na.omit(as.vector(as.matrix(patterns))))
  if (length(unique(row.names(patterns))) == sum(mod.number)) {
    ## Apply when each modular variant has a unique name
    names(patterns.list) <- row.names(patterns)
    
  } else {
    ## Create unique names for each modular variant (ignoring common feature 
    # among variants or different modules)
    names(patterns.list) <- 
      tolower(names(unlist(lapply(mod.number, function(x) seq(1:x)))))
    
  }
  
  ## Loading res.list
  if (is.null(res.list)) { 
    in.file <- 
      file.path(out.dir, paste("resList_", res.listName, ".rda", sep = ""))
    if (file.exists(in.file)) {
      load(in.file)
    } else {
      in.file <- file.path(out.dir, paste(res.listName, ".rda", sep = ""))
      if (file.exists(in.file)) {
        load(in.file)
      } else {
        stop("File \"", in.file, "\" not found. \n")
      }
    }
    cat("Loading list of read-mapping hits: \"", in.file, "\".\n", sep = "")
  }
  
  mod.comb.len <- length(mod.comb)
  
  ##### 1: Output table 
  # Displaying the reference sequence to which each read was mapped.
  if (is.null(res.list.lengths) || is.null(res.list.ids)) {
    
    if (!existsFunction("ParseInfoResultsList")) {
      source(file.path(modseq.dir, "R/functions/ParseInfoResultsList.R"))
    }
    retList <- 
      ParseInfoResultsList(res.list = res.list, mod.comb = mod.comb, 
                           mod.comb.len = mod.comb.len, num.cores = num.cores)
    res.list.lengths <- retList[[1]]
    res.list.ids <- retList[[2]]
    
  }
  
  res.list.seq <- 
    unlist(mcmapply(function (x,n) rep(x,n), x = names(res.list),
                    n = res.list.lengths, USE.NAMES = FALSE, 
                    mc.cores = num.cores), use.names = FALSE)
  
  out.table <- data.frame("Read ID" = unlist(res.list, use.names = FALSE),
                          "Reference ID" = res.list.ids, 
                          "Reference sequence" = res.list.seq,
                          stringsAsFactors = FALSE)
  out.file <- 
    file.path(out.dir, 
              paste(res.listName, "_readMapping_table.csv", sep = ""))
  cat("Exporting: \"", out.file, "\" ... \n", sep = "")
  write.csv(out.table, file = out.file)
  
  ###### 2: Last search round: Distribution of modular variants
  ## Number of hits per modular variant in the last search round
  aux.modDist <- table(
    factor(unlist(strsplit(res.list.ids, ":")), levels = names(patterns.list))
    )
  
  mod.id2names <- 
    GetVariantsNames(patterns = patterns, modules.tot = mod.tot, 
                     modseq.dir = modseq.dir, num.cores = num.cores)
  names(mod.id2names) <- names(patterns.list)
  
  df.modDist <- data.frame(
    "module" =
      factor(rep(names(patterns), mod.number), levels = names(patterns)),
    "variant" = mod.id2names[names(aux.modDist)], 
    "counts"  = as.numeric(aux.modDist), row.names = NULL
    )
  out.file <- 
    file.path(out.dir, 
              paste(out.filename, "_FreqVariantsPerModule_table.csv", sep = ""))
  cat("Exporting distribution of modular variants: \"", out.file, "\". \n",
      sep = "")
  write.csv(df.modDist, file = out.file)
  
  df.modDist$variantNumber <- unlist(
    mclapply(mod.number, seq_len, mc.cores = num.cores), use.names = FALSE)
  df.modDist$counts <- df.modDist$counts * 100 / length(unlist(res.list))
  
  out.file <- 
    file.path(out.dir, 
              paste(out.filename, "_FreqVariantsPerModule_graph.pdf", sep = ""))
  cat("Plotting distribution of modular variants in the last search round: \"",
      out.file, "\". \n", sep = "")
  PlotVariantFrequencies(data = df.modDist[df.modDist$counts != 100, ], 
                         x.var = "variantNumber", y.var = "counts", 
                         z.var = "variant", facet = "module", 
                         out.file = out.file)
  
  ##### 3: Distribution of module combinations
  mod.dstr <- sort(res.list.lengths, decreasing = TRUE)
  df.mod.dstr <- data.frame("x" = seq_len(mod.comb.len) * 100 / mod.comb.len, 
                            "y" = mod.dstr)
  
  out.file <- 
    file.path(out.dir, 
              paste(out.filename, "_ModComb_distribution_graph.pdf", sep = ""))
  cat("Plotting distribution of module combinations: \"", out.file, "\". \n", 
      sep = "")

  PlotModuleCombinationsDistribution(data = df.mod.dstr, x.var = "x", 
                                     y.var = "y", out.file = out.file)

}
